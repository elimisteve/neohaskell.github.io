"use strict";(self.webpackChunkneohaskell_github_io=self.webpackChunkneohaskell_github_io||[]).push([[340],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var i=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=i.createContext({}),c=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return i.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(n),m=o,h=p["".concat(s,".").concat(m)]||p[m]||u[m]||a;return n?i.createElement(h,r(r({ref:t},d),{},{components:n})):i.createElement(h,r({ref:t},d))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,r=new Array(a);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:o,r[1]=l;for(var c=2;c<a;c++)r[c]=n[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7045:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var i=n(7462),o=(n(7294),n(3905));const a={sidebar_position:2},r="Understanding Complexity",l={unversionedId:"extra-topics/complexity",id:"extra-topics/complexity",title:"Understanding Complexity",description:"Introduction",source:"@site/docs/extra-topics/complexity.mdx",sourceDirName:"extra-topics",slug:"/extra-topics/complexity",permalink:"/docs/extra-topics/complexity",draft:!1,editUrl:"https://github.com/neohaskell/neohaskell.github.io/tree/main/docs/extra-topics/complexity.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"The NeoHaskell Genesis",permalink:"/docs/extra-topics/neohaskell-genesis"},next:{title:"Integrating NeoHaskell",permalink:"/docs/extra-topics/integrating-neohaskell"}},s={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Mutable State",id:"mutable-state",level:2},{value:"Solution: Avoiding Mutable State",id:"solution-avoiding-mutable-state",level:3},{value:"Avoiding Complex Abstractions",id:"avoiding-complex-abstractions",level:2},{value:"Solution: Embracing Declarative Code",id:"solution-embracing-declarative-code",level:3},{value:"Tool Overhead in Modern Development",id:"tool-overhead-in-modern-development",level:2},{value:"Solution: Unified Tooling with NeoHaskell&#39;s <code>neo</code>",id:"solution-unified-tooling-with-neohaskells-neo",level:3},{value:"Complexity Without Defined Contracts",id:"complexity-without-defined-contracts",level:2},{value:"Solution: Versatile Static Typing for Reliable Contracts",id:"solution-versatile-static-typing-for-reliable-contracts",level:3},{value:"Conclusion",id:"conclusion",level:2}],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"understanding-complexity"},"Understanding Complexity"),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"Navigating the intricate world of software development can be likened to voyaging through a dense, uncharted jungle for beginners. Understanding ",(0,o.kt)("em",{parentName:"p"},"complexity")," that emerges from various components like mutable state, complex abstractions, and a plethora of development tools, is important, as it will become a point of reference for the things that we want to avoid."),(0,o.kt)("p",null,"For example, imagine a massive social networking platform suddenly losing its entire development team, who held all knowledge of the intricate code and architecture. The complex codebase left behind would make even the most skilled developers confused and slow to make progress."),(0,o.kt)("p",null,"Probably, in the face of such complexity and potential for numerous errors, the decision made would be to not wrestle with the old, dense code, but to rebuild the platform from scratch using current technologies and practices."),(0,o.kt)("p",null,"This exemplifies the challenges in software development where technical debt and complexity can sometimes outweigh the potential benefits of continuing with an existing system."),(0,o.kt)("p",null,"The point of NeoHaskell is to help you avoid these kind of pitfalls as much as possible, writing code that is easy to understand, maintain, and extend. Or at least easier than in traditional, mainstream languages."),(0,o.kt)("p",null,"This page is about understanding complexity, and how to avoid it. Later in the documentation, you will be learning NeoHaskell and all the concepts attached to it, and how they help you."),(0,o.kt)("h2",{id:"mutable-state"},"Mutable State"),(0,o.kt)("p",null,"Mutable state means that variables in a program can change their values over time. This can make software complex because when something goes wrong, it might be hard to figure out which part of the code changed the variable's value and caused the issue."),(0,o.kt)("p",null,"Imagine several people trying to write a story together but they can change what others have written at any time - it's tough to keep track!"),(0,o.kt)("p",null,"In coding, especially when different parts of the program are running at the same time (concurrently), managing and ensuring variables change in a controlled and expected way becomes tricky and can lead to unexpected problems and bugs."),(0,o.kt)("h3",{id:"solution-avoiding-mutable-state"},"Solution: Avoiding Mutable State"),(0,o.kt)("p",null,"Avoiding mutable state can be achieved through a concept called immutability."),(0,o.kt)("p",null,"Immutability as a solution means that once a variable is created, it cannot be changed. If we want a different value, we create a new variable instead of changing the old one. This makes our code easier to understand and troubleshoot because we don't have to track down all the places where a variable might be changed."),(0,o.kt)("p",null,"Going back to our group story-writing example, it's like saying once someone writes a sentence, it stays written that way. Anyone else who wants to add to the story writes a new sentence instead of changing the old ones. This makes it clear what each person wrote and in what order, removing the chaos of changes happening everywhere."),(0,o.kt)("p",null,"In coding, immutability can make our programs simpler and safer, especially when different parts of the program run at the same time, by avoiding unexpected changes to our variables."),(0,o.kt)("p",null,"This could be seen as something hard and inefficient, but in reality, if the language is designed with immutability in mind, it can be very easy and efficient."),(0,o.kt)("h2",{id:"avoiding-complex-abstractions"},"Avoiding Complex Abstractions"),(0,o.kt)("p",null,"In the quest to achieve clean and efficient code, developers often employ abstractions to encapsulate complex logic and foster reuse. However, abstractions, when overly complex or misapplied, can shroud the codebase in a veil of opacity, particularly bewildering for newcomers who must unravel these intricate webs. An abstraction, no matter how well known it is, might encapsulate a multitude of operations, variables, and dependencies under its umbrella. Yet, for a developer unfamiliar with its intricacies, discerning its functionality, applications, and impact on the code can be a perplexing endeavor. These abstractions can become like a convoluted labyrinth where the logical flow gets lost amidst the myriad of intertwined paths, thereby elevating the cognitive load and stifling the code's readability and maintainability."),(0,o.kt)("h3",{id:"solution-embracing-declarative-code"},"Solution: Embracing Declarative Code"),(0,o.kt)("p",null,"In mitigating the complexities introduced by abstractions, adopting a declarative coding approach offers a serene middle-ground, making code logic explicit while still maintaining a level of abstraction that guards against descending into the weeds of overly detailed implementations. Declarative code emphasizes describing the \u201cwhat\u201d over the \u201chow\u201d, focusing on the desired outcome without getting bogged down in the intricate mechanics of implementation."),(0,o.kt)("p",null,"For instance, instead of complex abstractions, we might employ utility functions, as well as using descriptive variable and function names. By harnessing declarative code, we create a transparent, comprehensible codebase where functionality is clear, intentions are explicit, and new developers can understand and contribute without having to decode a maze of abstractions. The delicate balance of making intentions clear while avoiding over-engineering is critical in maintaining a clean, manageable, and developer-friendly environment."),(0,o.kt)("h2",{id:"tool-overhead-in-modern-development"},"Tool Overhead in Modern Development"),(0,o.kt)("p",null,"In the multifaceted environment of software development, the incorporation of various tools - from version control systems like Git to containerization technologies like Docker - is ostensibly inevitable and ostensibly beneficial, aimed at streamlining, optimizing, and enhancing the development workflow."),(0,o.kt)("p",null,"However, an aspect often overlooked is the inherent complexity and cognitive overhead these tools can introduce, particularly for developers new to the ecosystem.\nThe necessity to climb multiple learning curves simultaneously - understanding the project code and concurrently mastering myriad tools - can morph into a strenuous juggling act. Each tool, while powerful, demands an investment of time and cognitive energy to learn its functionalities, interfaces, and best practices."),(0,o.kt)("p",null,"The complexity amplifies when these tools interplay, introducing additional layers of intricacies and potential for issues that developers must navigate, sometimes diverting attention and resources from the primary development tasks."),(0,o.kt)("h3",{id:"solution-unified-tooling-with-neohaskells-neo"},"Solution: Unified Tooling with NeoHaskell's ",(0,o.kt)("inlineCode",{parentName:"h3"},"neo")),(0,o.kt)("p",null,"Embracing a simplified, unified tooling approach, NeoHaskell introduces ",(0,o.kt)("inlineCode",{parentName:"p"},"neo"),", a single Command Line Interface (CLI) tool designed to alleviate the complexity often associated with using multiple development tools. Instead of requiring developers to grapple with a variety of tools, each with its unique syntax and intricacies, ",(0,o.kt)("inlineCode",{parentName:"p"},"neo")," consolidates numerous functionalities into a single, coherent interface that supports building, testing, code generation, and more. This multipurpose tool helps in minimizing the cognitive load and the time investment typically required to learn and navigate through multiple platforms."),(0,o.kt)("h2",{id:"complexity-without-defined-contracts"},"Complexity Without Defined Contracts"),(0,o.kt)("p",null,"A lack of defined contracts in software development, meaning clear specifications about how code components interact and communicate, introduces complexity and cognitive load. Without these established expectations regarding function inputs and outputs, developers face ambiguity and potential miscommunications between code segments, which increases the likelihood of errors and makes the code harder to understand and maintain."),(0,o.kt)("h3",{id:"solution-versatile-static-typing-for-reliable-contracts"},"Solution: Versatile Static Typing for Reliable Contracts"),(0,o.kt)("p",null,"Utilizing static typing helps enforce clear contracts by validating data types at compile-time, preventing type-related errors before the code is executed. In NeoHaskell, defining exact data types for function inputs and outputs helps set explicit expectations and ensure consistent interactions between code components, reducing complexity and increasing code reliability and clarity."),(0,o.kt)("p",null,"In some languages like Java, or C, static typing can be very verbose and cumbersome, but in NeoHaskell, the compiler will figure out most of the types for you, so you don't have to write them out. This makes static typing a very powerful tool, without the downsides of verbosity."),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"We've explored several challenges in software development in this guide: the difficulties caused by ",(0,o.kt)("strong",{parentName:"p"},"Mutable State"),", the confusion from ",(0,o.kt)("strong",{parentName:"p"},"Avoiding Complex Abstractions"),", the extra work due to ",(0,o.kt)("strong",{parentName:"p"},"Tool Overhead"),", and the problems from ",(0,o.kt)("strong",{parentName:"p"},"Complexity Without Defined Contracts"),". These topics are vital but are only part of the picture. Issues like handling dependencies, maintaining scalable architecture, and keeping good documentation also add complexity and cognitive stress in developing software."),(0,o.kt)("p",null,"Even with these challenges, the next sections will introduce ideas to make software development simpler and more enjoyable. These ideas will help manage and reduce complexity, making the development process clear and fun. Whether you are a new developer or have lots of experience, the coming content aims to make your work in software development easier and more organized. Let's continue to explore and simplify the world of software development together."))}u.isMDXComponent=!0}}]);