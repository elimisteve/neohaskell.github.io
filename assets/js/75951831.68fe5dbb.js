"use strict";(self.webpackChunkneohaskell_github_io=self.webpackChunkneohaskell_github_io||[]).push([[814],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,s=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(n),m=o,d=u["".concat(l,".").concat(m)]||u[m]||h[m]||s;return n?a.createElement(d,r(r({ref:t},p),{},{components:n})):a.createElement(d,r({ref:t},p))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=n.length,r=new Array(s);r[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:o,r[1]=i;for(var c=2;c<s;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},165:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(7294);const o=e=>{let{issue:t,absolute:n}=e;const[o,s]=a.useState("loading"),[r,i]=a.useState();(0,a.useEffect)((()=>{try{fetch(`https://api.github.com/repos/neohaskell/neohaskell/issues/${t}`).then((e=>e.json())).then((e=>{e&&(s(e.state),i(e.title))}))}catch(e){console.error(e)}}),[]);const l=o?`NOT IMPLEMENTED YET: #${t} - ${r}`:"LOADING",c=`tooltip ${n?"absolute z-10 p-4":""}`;return a.createElement("a",{className:c,"data-tip":l,target:"_blank",href:`https://github.com/neohaskell/neohaskell/issues/${t}`},a.createElement("div",{className:`badge border-black ${{open:"badge-warning",closed:"hidden",loading:"badge-primary"}[o]} badge-lg`}))}},1645:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(7294);function o(e){let{src:t,sourceLink:n,alt:o}=e;return a.createElement("figure",{className:"!flex !flex-col !place-items-center"},a.createElement("img",{src:t,alt:o}),a.createElement("figcaption",{className:"!text-xs"},`Source: ${n}`))}},1374:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(7462),o=(n(7294),n(3905)),s=n(165);n(1645);const r={sidebar_position:1},i="Constants",l={unversionedId:"essentials/constants",id:"essentials/constants",title:"Constants",description:"The documentation that you're reading is a design document where most of",source:"@site/docs/essentials/constants.mdx",sourceDirName:"essentials",slug:"/essentials/constants",permalink:"/docs/essentials/constants",draft:!1,editUrl:"https://github.com/neohaskell/neohaskell.github.io/tree/main/docs/essentials/constants.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Doing Math",permalink:"/docs/essentials/math"},next:{title:"Laziness",permalink:"/docs/essentials/laziness"}},c={},p=[{value:"Declaring Constants",id:"declaring-constants",level:2},{value:"A Note on Naming Convention",id:"a-note-on-naming-convention",level:2},{value:"They Are Really Constant, Tho",id:"they-are-really-constant-tho",level:2}],u={toc:p},h="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(h,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"constants"},"Constants"),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"The documentation that you're reading is a design document where most of\nthe features you're reading are yet to be implemented. Check the ",(0,o.kt)("a",{parentName:"p",href:"/docs/docs-intro"},"Note on the Docs"))),(0,o.kt)("p",null,"NeoHaskell promotes the usage of ",(0,o.kt)("em",{parentName:"p"},"variables that do not change over time"),". These kinds of variables are named\n",(0,o.kt)("strong",{parentName:"p"},"constants"),"."),(0,o.kt)("p",null,"In most of programming languages, what you expect is to use regular variables that can change, and then only\nif you think that some variable should not change, you create a constant. In NeoHaskell, the approach is the\nopposite: you should use constants by default, and only if you think that some variable should change, you\ncreate a ",(0,o.kt)("strong",{parentName:"p"},"mutable variable")," (we will talk about mutable variables in later sections)."),(0,o.kt)("p",null,"In software development, mutable variables introduce cognitive overhead because ",(0,o.kt)("strong",{parentName:"p"},"developers must track changes to their values throughout the code"),", which can lead to unpredictable side effects and bugs. On the other hand, constants offer clarity and predictability. When you see a constant, ",(0,o.kt)("strong",{parentName:"p"},"you instantly know its value will remain consistent everywhere"),", eliminating the mental effort of tracking potential changes and simplifying the code's comprehension."),(0,o.kt)("h2",{id:"declaring-constants"},"Declaring Constants"),(0,o.kt)("p",null,"Declaring constants is easy, just write the name of the constant, followed by an equals sign and the value of the constant:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> myConstant = 10\n")),(0,o.kt)("p",null,"The above code declares a constant named ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant")," with the value ",(0,o.kt)("inlineCode",{parentName:"p"},"10"),". You can now use it to perform operations:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> myConstant + 5\n15\n")),(0,o.kt)("h2",{id:"a-note-on-naming-convention"},"A Note on Naming Convention"),(0,o.kt)("p",null,"Note how the constant name is written with the first letter in lowercase, and then for each word, the first letter is written in uppercase. This is called ",(0,o.kt)("strong",{parentName:"p"},"camelCase")," and is the naming convention in NeoHaskell for ",(0,o.kt)("strong",{parentName:"p"},"constants"),", ",(0,o.kt)("strong",{parentName:"p"},"variables")," and ",(0,o.kt)("strong",{parentName:"p"},"functions"),"."),(0,o.kt)("p",null,"Another thing that might have caught your attention is that it is not written in all caps, like ",(0,o.kt)("inlineCode",{parentName:"p"},"MY_CONSTANT"),". This is because in NeoHaskell, everything is a constant, and variables have special syntax to declare them as mutable. So, there is no need to write constants in all caps."),(0,o.kt)("p",null,"If you try to define a constant in all caps, you will get an error message: ",(0,o.kt)(s.Z,{issue:"79",mdxType:"Badge"})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"neo> MY_CONSTANT = 10\nerror:\n  It looks like you're trying to define a constant in all caps. In NeoHaskell, constants are defined in `camelCase`,\n  as names that start with uppercase letters are reserved for types.\n\n  Read more about constants in the docs: https://neohaskell.io/docs/essentials/constants\n")),(0,o.kt)("h2",{id:"they-are-really-constant-tho"},"They Are Really Constant, Tho"),(0,o.kt)("p",null,"You might be wondering, what happens if I try to change the value of a constant? Let's try it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> myConstant = 10\nneo> myConstant\n10\nneo> myConstant = 20\nneo> myConstant\n20\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Hey, you lied to me! You said that constants are constant, but I just changed the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant"),"!")),(0,o.kt)("p",null,"Well, not really. What you did was to create a new constant named ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant")," with the value ",(0,o.kt)("inlineCode",{parentName:"p"},"20"),". The old constant named ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant")," with the value ",(0,o.kt)("inlineCode",{parentName:"p"},"10")," doesn't exist anymore."),(0,o.kt)("p",null,"Let's try doing one thing, incrementing the constant by one:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> myConstant = 10\nneo> myConstant = myConstant + 1\nneo> myConstant\n\n-- oops! the REPL froze! \ud83e\udd76\n")),(0,o.kt)("p",null,"Nope, it's not your computer, the REPL just froze (you can press ",(0,o.kt)("inlineCode",{parentName:"p"},"Ctrl + C")," to cancel the operation), and it is an expected behavior."),(0,o.kt)("p",null,"Why is this happening? What's happening here is that when defining a constant, the compiler is not really calculating the\nvalue on the right side of the equals sign, but instead, it is ",(0,o.kt)("strong",{parentName:"p"},"just storing the expression as it is"),"."),(0,o.kt)("p",null,"When you try to use it (like when you write ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant")," in the REPL), the compiler will calculate and store the value of the\nconstant at that moment, as it is the first time that you are using it. This is called ",(0,o.kt)("strong",{parentName:"p"},"lazy evaluation"),", and we will go more\nin depth in the next section."))}m.isMDXComponent=!0}}]);