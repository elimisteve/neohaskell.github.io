"use strict";(self.webpackChunkneohaskell_github_io=self.webpackChunkneohaskell_github_io||[]).push([[8076],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),u=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(i.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(n),d=r,h=p["".concat(i,".").concat(d)]||p[d]||m[d]||o;return n?a.createElement(h,l(l({ref:t},c),{},{components:n})):a.createElement(h,l({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=d;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[p]="string"==typeof e?e:r,l[1]=s;for(var u=2;u<o;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(7294),r=n(6010);const o={tabItem:"tabItem_Ymn6"};function l(e){let{children:t,hidden:n,className:l}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(o.tabItem,l),hidden:n},t)}},4866:(e,t,n)=>{n.d(t,{Z:()=>k});var a=n(7462),r=n(7294),o=n(6010),l=n(2466),s=n(6550),i=n(1980),u=n(7392),c=n(12);function p(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function m(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??p(n);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function d(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,s.k6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,i._X)(o),(0,r.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(a.location.search);t.set(o,e),a.replace({...a.location,search:t.toString()})}),[o,a])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,o=m(e),[l,s]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!d({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:o}))),[i,u]=h({queryString:n,groupId:a}),[p,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,o]=(0,c.Nk)(n);return[a,(0,r.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:a}),y=(()=>{const e=i??p;return d({value:e,tabValues:o})?e:null})();(0,r.useLayoutEffect)((()=>{y&&s(y)}),[y]);return{selectedValue:l,selectValue:(0,r.useCallback)((e=>{if(!d({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);s(e),u(e),f(e)}),[u,f,o]),tabValues:o}}var y=n(2389);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function g(e){let{className:t,block:n,selectedValue:s,selectValue:i,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:p}=(0,l.o5)(),m=e=>{const t=e.currentTarget,n=c.indexOf(t),a=u[n].value;a!==s&&(p(t),i(a))},d=e=>{let t=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":n},t)},u.map((e=>{let{value:t,label:n,attributes:l}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,key:t,ref:e=>c.push(e),onKeyDown:d,onClick:m},l,{className:(0,o.Z)("tabs__item",b.tabItem,l?.className,{"tabs__item--active":s===t})}),n??t)})))}function v(e){let{lazy:t,children:n,selectedValue:a}=e;const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},o.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function w(e){const t=f(e);return r.createElement("div",{className:(0,o.Z)("tabs-container",b.tabList)},r.createElement(g,(0,a.Z)({},e,t)),r.createElement(v,(0,a.Z)({},e,t)))}function k(e){const t=(0,y.Z)();return r.createElement(w,(0,a.Z)({key:String(t)},e))}},165:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(7294);const r=e=>{let{issue:t,absolute:n}=e;const[r,o]=a.useState("loading"),[l,s]=a.useState();(0,a.useEffect)((()=>{try{fetch(`https://api.github.com/repos/neohaskell/neohaskell/issues/${t}`).then((e=>e.json())).then((e=>{e&&(o(e.state),s(e.title))}))}catch(e){console.error(e)}}),[]);const i=r?`NOT IMPLEMENTED YET: #${t} - ${l}`:"LOADING",u=`tooltip ${n?"absolute z-10 p-4":""}`;return a.createElement("a",{className:u,"data-tip":i,target:"_blank",href:`https://github.com/neohaskell/neohaskell/issues/${t}`},a.createElement("div",{className:`badge border-black ${{open:"badge-warning",closed:"hidden",loading:"badge-primary"}[r]} badge-lg`}))}},1645:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(7294);function r(e){let{src:t,sourceLink:n,alt:r}=e;return a.createElement("figure",{className:"!flex !flex-col !place-items-center"},a.createElement("img",{src:t,alt:r}),a.createElement("figcaption",{className:"!text-xs"},`Source: ${n}`))}},1886:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>u,toc:()=>p});var a=n(7462),r=(n(7294),n(3905)),o=n(4866),l=n(5162);n(165),n(1645);const s={sidebar_position:5},i="Enums",u={unversionedId:"essentials/enums",id:"essentials/enums",title:"Enums",description:"The documentation that you're reading is a design document where most of",source:"@site/docs/essentials/enums.mdx",sourceDirName:"essentials",slug:"/essentials/enums",permalink:"/docs/essentials/enums",draft:!1,editUrl:"https://github.com/neohaskell/neohaskell.github.io/tree/main/docs/essentials/enums.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Meeting the Types",permalink:"/docs/essentials/types"},next:{title:"Extra Topics",permalink:"/docs/category/extra-topics"}},c={},p=[{value:"Defining an enum",id:"defining-an-enum",level:2},{value:"Enums with Attached Values",id:"enums-with-attached-values",level:2},{value:"Defining Enums with Attached Values",id:"defining-enums-with-attached-values",level:3},{value:"Benefits of Enums with Attached Values",id:"benefits-of-enums-with-attached-values",level:3},{value:"Next Steps",id:"next-steps",level:2}],m={toc:p},d="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"enums"},"Enums"),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The documentation that you're reading is a design document where most of\nthe features you're reading are yet to be implemented. Check the ",(0,r.kt)("a",{parentName:"p",href:"/docs/docs-intro"},"Note on the Docs"))),(0,r.kt)("p",null,"In the previous section, we learned how to start using NeoHaskell's type system, we learned how to annotate constants\nand functions, and also we saw how to start modelling our domain using wrapper types, which allowed us to\navoid primitive obssession and to give concrete more meaningful names to our types, more according to the domain of our\napplication."),(0,r.kt)("p",null,"There are certain cases where we might want to model a thing that can only have a finite number of values, for example,\nthe state of a lightbulb, the colors of a rainbow, the days of the week, etc. Instead of using strings to represent these values, we use ",(0,r.kt)("strong",{parentName:"p"},"enums"),"."),(0,r.kt)("p",null,"Similar to wrapper types, enums allow you to avoid primitive obsession. For example, instead of using a ",(0,r.kt)("inlineCode",{parentName:"p"},"Bool")," to represent\nthe state of a lightbulb, we can use an enum with two cases: ",(0,r.kt)("inlineCode",{parentName:"p"},"On")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Off"),". This way, we can't accidentally pass a ",(0,r.kt)("inlineCode",{parentName:"p"},"Bool"),"\nthat represents the state of a lightbulb to a function that expects a ",(0,r.kt)("inlineCode",{parentName:"p"},"Bool")," that represents the state of a TV."),(0,r.kt)("h2",{id:"defining-an-enum"},"Defining an enum"),(0,r.kt)("p",null,"To define an enum, we use the ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," keyword followed by the name of the enum and the cases that it can have, separated by\nvertical bars (",(0,r.kt)("inlineCode",{parentName:"p"},"|"),"). For example, to define an enum that represents the state of a lightbulb, we can do the following:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"NeoHaskell",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data LightbulbState\n  = On\n  | Off\n"))),(0,r.kt)(l.Z,{value:"TypeScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"enum LightbulbState {\n  On,\n  Off,\n}\n")))),(0,r.kt)("p",null,"You can add as many cases as you want. In fact, if your application handles some specific values of a type with infinite values like\n",(0,r.kt)("inlineCode",{parentName:"p"},"Int"),", it is much better to use an enum instead of an ",(0,r.kt)("inlineCode",{parentName:"p"},"Int")," because it will be much more clear what the function expects and\nwhat it returns."),(0,r.kt)("p",null,"Imagine that you're developing a videogame, and you want to represent with how many lives does a player start. Let's suppose that a\nplayer can only start with between two and six lives. Instead of using ",(0,r.kt)("inlineCode",{parentName:"p"},"Int"),", which has no limits, we can use an enum with different\ncases. This way, we can't accidentally pass a ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," to a function that expects the number of starting lives of a\nplayer, or have a bug down there in our code that makes the player accidentally start with one million lives:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"NeoHaskell",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data PlayerLives\n  = Two\n  | Three\n  | Four\n  | Five\n  | Six\n"))),(0,r.kt)(l.Z,{value:"TypeScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"enum PlayerLives {\n  Two,\n  Three,\n  Four,\n  Five,\n  Six,\n}\n")))),(0,r.kt)("p",null,"One advantage of NeoHaskell's enums over TypeScript's (and most mainstream languages) enums is that the values of a NeoHaskell enum\nare the values themselves and they are not usable in place of other types that are not the enum itself, while in TypeScript,\nfor example, the values of an enum are numbers that represent the position of the case in the enum, and they can be used in any place\nwhere a number is expected. Compare the following examples:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"NeoHaskell",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data PlayerLives\n  = Two\n  | Three\n  | Four\n  | Five\n  | Six\n\nneo> Two + 4\n-- TYPE MISMATCH ----------------------------\nAttempting to add two values, but the first value doesn't match the type of the second value:\n\n    Two + 4\n    ^^^\n\n`Two` is of type:\n\n    PlayerLives\n\nBut `(+)` needs the 1st argument to be:\n\n    Int\n"))),(0,r.kt)(l.Z,{value:"TypeScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"enum PlayerLives {\n  Two,\n  Three,\n  Four,\n  Five,\n  Six,\n}\n\nconsole.log(PlayerLives.Two + 4); // 4\n\n// The above weirdly prints 4 because the value of `PlayerLives.Two` is 0, and 0 + 4 = 4\n")))),(0,r.kt)("p",null,"It definitely is much better to have this fail at compile time than to have a weird bug where there's a value called\n",(0,r.kt)("inlineCode",{parentName:"p"},"Two")," that is actually ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," and that can be used in place of a number."),(0,r.kt)("h2",{id:"enums-with-attached-values"},"Enums with Attached Values"),(0,r.kt)("p",null,"In addition to simple enums, NeoHaskell allows the creation of more complex enums by attaching values to enum cases. These are powerful constructs that enable enums to carry additional, context-specific data. This feature is particularly useful when a simple label (like ",(0,r.kt)("inlineCode",{parentName:"p"},"On")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"Off"),") isn't sufficient to express all the necessary information about an enumeration case."),(0,r.kt)("h3",{id:"defining-enums-with-attached-values"},"Defining Enums with Attached Values"),(0,r.kt)("p",null,"When defining an enum in NeoHaskell, you can specify one or more values to be attached to each case. These values can be of any type, including other enums or complex types. This makes enums a flexible tool for modeling a wide variety of data."),(0,r.kt)("p",null,"Consider a ",(0,r.kt)("inlineCode",{parentName:"p"},"Color")," enum where a color can be represented in different color spaces. Some colors might be represented in the RGB color space, others in grayscale, and yet others as hexadecimal strings. Here's how you can define such an enum:"),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"NeoHaskell",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"data Color\n  = Rgb Int Int Int  -- Red, Green, Blue components\n  | Grayscale Int    -- Intensity of gray\n  | Hex String       -- Hexadecimal string\n\n-- To create a value of type `Color`, you use the following syntax:\nmyFavoriteColor = Rgb 0 255 0\n"))),(0,r.kt)(l.Z,{value:"TypeScript",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'// In Typescript there\'s no way to attach values to enum cases, so we have to use a workaround\n\n// First we define a type that represents the different color types\nenum ColorType {\n  Rgb = "Rgb",\n  Grayscale = "Grayscale",\n  Hex = "Hex",\n}\n\n// Then we define a type that represents a color\ntype Color =\n  | { type: ColorType.Rgb; r: number; g: number; b: number }\n  | { type: ColorType.Grayscale; intensity: number }\n  | { type: ColorType.Hex; hexStr: string };\n\n// And now we define a couple of functions to create colors\nconst Rgb = (r: number, g: number, b: number): Color => ({\n  type: ColorType.Rgb,\n  r,\n  g,\n  b,\n});\n\nconst Grayscale = (intensity: number): Color => ({\n  type: ColorType.Grayscale,\n  intensity,\n});\n\nconst Hex = (hexStr: string): Color => ({\n  type: ColorType.Hex,\n  hexStr,\n});\n\n// To create a value of type `Color`, we use the functions that we defined above\nconst myFavoriteColor = Rgb(0, 255, 0);\n')))),(0,r.kt)("p",null,"Each case of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Color")," enum carries different types of values:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RGB")," carries three ",(0,r.kt)("inlineCode",{parentName:"li"},"Int")," values representing the red, green, and blue components of a color."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Grayscale")," carries a single ",(0,r.kt)("inlineCode",{parentName:"li"},"Int")," representing the intensity of gray."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Hex")," carries a ",(0,r.kt)("inlineCode",{parentName:"li"},"String")," representing the color in hexadecimal format.")),(0,r.kt)("p",null,"This design encapsulates the concept that a color can be represented in different ways, but ultimately, it's still a color within the domain of your application."),(0,r.kt)("h3",{id:"benefits-of-enums-with-attached-values"},"Benefits of Enums with Attached Values"),(0,r.kt)("p",null,"Using enums with attached values has several benefits:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Richer Data Modeling"),": You can model complex data structures in a type-safe manner, ensuring that the attached data aligns with the specific case of the enum."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Clarity"),": The code clearly communicates what data is expected with each enum case, leading to self-documenting code."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Safety"),": The compiler can enforce that all possible cases are handled in functions, reducing the likelihood of runtime errors. A function that doesn't handle all possible cases for an enum will fail to compile.")),(0,r.kt)("p",null,"In summary, enums with attached values in NeoHaskell are a powerful feature for developers to express complex data structures cleanly and safely. They extend the utility of simple enums by allowing the carrying of additional information, which can be crucial for many applications that require detailed data representation and manipulation. And given the event-driven nature of NeoHaskell, enums with attached values are a natural fit for modeling events and their associated data."),(0,r.kt)("h2",{id:"next-steps"},"Next Steps"),(0,r.kt)("p",null,"We've learned how to define enums, and how to attach values to enum cases, but we haven't seen how to use them yet.\nIn the next section, we'll start learning about handling boolean conditions through the usage of ",(0,r.kt)("inlineCode",{parentName:"p"},"if-then-else"),",\nand later, we will transition towards pattern matching, which will help you to use your enums."))}h.isMDXComponent=!0}}]);