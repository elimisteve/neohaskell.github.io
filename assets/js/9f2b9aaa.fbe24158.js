"use strict";(self.webpackChunkneohaskell_github_io=self.webpackChunkneohaskell_github_io||[]).push([[5957],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=u(n),h=o,d=c["".concat(s,".").concat(h)]||c[h]||m[h]||r;return n?a.createElement(d,l(l({ref:t},p),{},{components:n})):a.createElement(d,l({ref:t},p))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,l=new Array(r);l[0]=h;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[c]="string"==typeof e?e:o,l[1]=i;for(var u=2;u<r;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>l});var a=n(7294),o=n(6010);const r={tabItem:"tabItem_Ymn6"};function l(e){let{children:t,hidden:n,className:l}=e;return a.createElement("div",{role:"tabpanel",className:(0,o.Z)(r.tabItem,l),hidden:n},t)}},4866:(e,t,n)=>{n.d(t,{Z:()=>N});var a=n(7462),o=n(7294),r=n(6010),l=n(2466),i=n(6550),s=n(1980),u=n(7392),p=n(12);function c(e){return function(e){return o.Children.map(e,(e=>{if(!e||(0,o.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:o}}=e;return{value:t,label:n,attributes:a,default:o}}))}function m(e){const{values:t,children:n}=e;return(0,o.useMemo)((()=>{const e=t??c(n);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function h(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function d(e){let{queryString:t=!1,groupId:n}=e;const a=(0,i.k6)(),r=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,s._X)(r),(0,o.useCallback)((e=>{if(!r)return;const t=new URLSearchParams(a.location.search);t.set(r,e),a.replace({...a.location,search:t.toString()})}),[r,a])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,r=m(e),[l,i]=(0,o.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:r}))),[s,u]=d({queryString:n,groupId:a}),[c,g]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,r]=(0,p.Nk)(n);return[a,(0,o.useCallback)((e=>{n&&r.set(e)}),[n,r])]}({groupId:a}),y=(()=>{const e=s??c;return h({value:e,tabValues:r})?e:null})();(0,o.useLayoutEffect)((()=>{y&&i(y)}),[y]);return{selectedValue:l,selectValue:(0,o.useCallback)((e=>{if(!h({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);i(e),u(e),g(e)}),[u,g,r]),tabValues:r}}var y=n(2389);const k={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function f(e){let{className:t,block:n,selectedValue:i,selectValue:s,tabValues:u}=e;const p=[],{blockElementScrollPositionUntilNextRender:c}=(0,l.o5)(),m=e=>{const t=e.currentTarget,n=p.indexOf(t),a=u[n].value;a!==i&&(c(t),s(a))},h=e=>{let t=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const n=p.indexOf(e.currentTarget)+1;t=p[n]??p[0];break}case"ArrowLeft":{const n=p.indexOf(e.currentTarget)-1;t=p[n]??p[p.length-1];break}}t?.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":n},t)},u.map((e=>{let{value:t,label:n,attributes:l}=e;return o.createElement("li",(0,a.Z)({role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,key:t,ref:e=>p.push(e),onKeyDown:h,onClick:m},l,{className:(0,r.Z)("tabs__item",k.tabItem,l?.className,{"tabs__item--active":i===t})}),n??t)})))}function b(e){let{lazy:t,children:n,selectedValue:a}=e;const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=r.find((e=>e.props.value===a));return e?(0,o.cloneElement)(e,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},r.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function w(e){const t=g(e);return o.createElement("div",{className:(0,r.Z)("tabs-container",k.tabList)},o.createElement(f,(0,a.Z)({},e,t)),o.createElement(b,(0,a.Z)({},e,t)))}function N(e){const t=(0,y.Z)();return o.createElement(w,(0,a.Z)({key:String(t)},e))}},165:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(7294);const o=e=>{let{issue:t,absolute:n}=e;const[o,r]=a.useState("loading"),[l,i]=a.useState();(0,a.useEffect)((()=>{try{fetch(`https://api.github.com/repos/neohaskell/neohaskell/issues/${t}`).then((e=>e.json())).then((e=>{e&&(r(e.state),i(e.title))}))}catch(e){console.error(e)}}),[]);const s=o?`NOT IMPLEMENTED YET: #${t} - ${l}`:"LOADING",u=`tooltip ${n?"absolute z-10 p-4":""}`;return a.createElement("a",{className:u,"data-tip":s,target:"_blank",href:`https://github.com/neohaskell/neohaskell/issues/${t}`},a.createElement("div",{className:`badge border-black ${{open:"badge-warning",closed:"hidden",loading:"badge-primary"}[o]} badge-lg`}))}},1645:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(7294);function o(e){let{src:t,sourceLink:n,alt:o}=e;return a.createElement("figure",{className:"!flex !flex-col !place-items-center"},a.createElement("img",{src:t,alt:o}),a.createElement("figcaption",{className:"!text-xs"},`Source: ${n}`))}},5242:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>u,default:()=>g,frontMatter:()=>s,metadata:()=>p,toc:()=>m});var a=n(7462),o=(n(7294),n(3905)),r=n(4866),l=n(5162),i=n(165);n(1645);const s={sidebar_position:4},u="Meeting the Types",p={unversionedId:"essentials/types",id:"essentials/types",title:"Meeting the Types",description:"The documentation that you're reading is a design document where most of",source:"@site/docs/essentials/types.mdx",sourceDirName:"essentials",slug:"/essentials/types",permalink:"/docs/essentials/types",draft:!1,editUrl:"https://github.com/neohaskell/neohaskell.github.io/tree/main/docs/essentials/types.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Functions",permalink:"/docs/essentials/functions"},next:{title:"Enums",permalink:"/docs/essentials/enums"}},c={},m=[{value:"Primitive types",id:"primitive-types",level:2},{value:"Annotating Constants",id:"annotating-constants",level:2},{value:"Checking the type of something",id:"checking-the-type-of-something",level:2},{value:"Avoiding primitive obsession",id:"avoiding-primitive-obsession",level:2},{value:"Why do I have to cast it?",id:"why-do-i-have-to-cast-it",level:3},{value:"Annotating Functions",id:"annotating-functions",level:2},{value:"Conclusion",id:"conclusion",level:2}],h={toc:m},d="wrapper";function g(e){let{components:t,...s}=e;return(0,o.kt)(d,(0,a.Z)({},h,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"meeting-the-types"},"Meeting the Types"),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"The documentation that you're reading is a design document where most of\nthe features you're reading are yet to be implemented. Check the ",(0,o.kt)("a",{parentName:"p",href:"/docs/docs-intro"},"Note on the Docs"))),(0,o.kt)("p",null,'One of the key features of NeoHaskell is its type system. Some people have preconceived\nideas about types, and they think that they get in the way of development process too\nmuch. This is usually because either the type system of the programming language they\nare using is not flexible enough, or that types come as an afterthought of the\ndevelopment process of their system, like if it is a "necessary bad thing".'),(0,o.kt)("p",null,"In NeoHaskell, types become your best friends. Not only because NeoHaskell's type\nsystem is quite different to type systems from other programming languages (e.g.\nit doesn't support inheritance, but supports ",(0,o.kt)("em",{parentName:"p"},"super-generics"),") but also because\nit becomes a very useful design tool for your software development toolbox."),(0,o.kt)("p",null,"With the NeoHaskell type system, you can sketch an outline of your system, that then\nyou can fill with the colors of an implementation. If your sketch outlines a dog,\nyou might color it better or worse, but it will still be a dog."),(0,o.kt)("h2",{id:"primitive-types"},"Primitive types"),(0,o.kt)("p",null,"In NeoHaskell, you've got the typical primitive types out of the box:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Type"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"),(0,o.kt)("th",{parentName:"tr",align:null},"Example"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"Int")),(0,o.kt)("td",{parentName:"tr",align:null},"Integer numbers"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"42"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"BigInt")),(0,o.kt)("td",{parentName:"tr",align:null},"Big integer numbers"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"1234567890123456789012345678901234567890"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"Float")),(0,o.kt)("td",{parentName:"tr",align:null},"Simple precision decimal numbers"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"3.1415"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"Double")),(0,o.kt)("td",{parentName:"tr",align:null},"Double precision decimal numbers"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"3.141592653589793"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"Bool")),(0,o.kt)("td",{parentName:"tr",align:null},"True or False"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"True"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"Char")),(0,o.kt)("td",{parentName:"tr",align:null},"Single characters"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"'a'"))))),(0,o.kt)("p",null,"Of course there are much more many types, but you can consider these as the\nmost basic ones."),(0,o.kt)("h2",{id:"annotating-constants"},"Annotating Constants"),(0,o.kt)("p",null,"Until now, when we wanted to create a constant, we just assigned a value to a name.\nIn the NeoHaskell repl, we could do it like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> myConstant = 42\n")),(0,o.kt)("p",null,"In this case, the compiler will automatically ",(0,o.kt)("em",{parentName:"p"},"infer")," that the type of ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant"),"\nis ",(0,o.kt)("inlineCode",{parentName:"p"},"Int"),". But it could be possible that we want it to be of type ",(0,o.kt)("inlineCode",{parentName:"p"},"BigInt"),", instead of\n",(0,o.kt)("inlineCode",{parentName:"p"},"Int"),"."),(0,o.kt)("p",null,"Given that types are a powerful tool for designing our programs, in NeoHaskell they\nget to be on their own line. This means, that for annotating the type of a constant,\nwe write the type on a line above the assignment line."),(0,o.kt)("p",null,"We write the type of a constant by using the ",(0,o.kt)("inlineCode",{parentName:"p"},"::"),' symbol, which reads as "is of type".'),(0,o.kt)(r.Z,{mdxType:"Tabs"},(0,o.kt)(l.Z,{value:"neohaskell",label:"NeoHaskell",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"myConstant :: BigInt\nmyConstant = 42\n"))),(0,o.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const myConstant: BigInt = 42;\n// Note, `BigInt` does not actually exist in TypeScript\n")))),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"In the NeoHaskell REPL, use the command ",(0,o.kt)("inlineCode",{parentName:"p"},":{")," to begin writing multiple lines,\nuse the command ",(0,o.kt)("inlineCode",{parentName:"p"},":}")," to end the multi-line input.")),(0,o.kt)("p",null,"If we wanted to try this on the REPL, we could do it like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> :{\n  myConstant :: BigInt\n  myConstant = 42\n  :}\n\nneo> myConstant\n42\n")),(0,o.kt)("h2",{id:"checking-the-type-of-something"},"Checking the type of something"),(0,o.kt)("p",null,"In the NeoHaskell REPL, you have a pretty useful command to check the type of stuff,\nyou can write ",(0,o.kt)("inlineCode",{parentName:"p"},":type")," and the name of something, and it will tell you the type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> :type myConstant\nmyConstant :: BigInt\n")),(0,o.kt)("p",null,'It replies with "myConstant is of type BigInt".'),(0,o.kt)("h2",{id:"avoiding-primitive-obsession"},"Avoiding primitive obsession"),(0,o.kt)("p",null,'There\'s this concept in software development called "primitive obsession" which\nessentially says that using primitive types for everything is bad.'),(0,o.kt)("p",null,"This is because they don't really tell you a story about how your program is\nstructured, or how your data gets transformed."),(0,o.kt)("p",null,'A counter-argument that people usually say against "wrapper types", or types whose\nonly reason of life is to give a name to a primitive type, is that they are not\nvery efficient. You now would need to have both the primitive value in memory, and\nthe wrapper that gives the type a name.'),(0,o.kt)("p",null,"In NeoHaskell, you get to create these wrapper types with no performance penalty."),(0,o.kt)("p",null,"In memory, it is only stored the actual value of the primitive type, but in compilation,\nthe compiler thinks that it is a different type."),(0,o.kt)("p",null,"To create a type of this kind, you use the ",(0,o.kt)("inlineCode",{parentName:"p"},"newtype")," keyword and do it this way:"),(0,o.kt)(r.Z,{mdxType:"Tabs"},(0,o.kt)(l.Z,{value:"neohaskell",label:"NeoHaskell",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"newtype Age = Age Int\n"))),(0,o.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'// Note: In TypeScript there is no such thing as newtype, so the closest thing\n// would be to emulate it with a workaround like the following:\ntype Age = number & { __tag: "Age" };\nconst Age = (age: number): Age => age as Age;\n')))),(0,o.kt)("p",null,"This creates a new type called ",(0,o.kt)("inlineCode",{parentName:"p"},"Age")," whose sole purpose is to be differentiated from\nother ",(0,o.kt)("inlineCode",{parentName:"p"},"Int"),"s. It also gives us a ",(0,o.kt)("em",{parentName:"p"},"constructor function")," called ",(0,o.kt)("inlineCode",{parentName:"p"},"Age")," that we can use to create a\nnew ",(0,o.kt)("inlineCode",{parentName:"p"},"Age")," value."),(0,o.kt)("p",null,"To create a constant with this type, you use it's ",(0,o.kt)("em",{parentName:"p"},"constructor function")," before the actual ",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," value:"),(0,o.kt)(r.Z,{mdxType:"Tabs"},(0,o.kt)(l.Z,{value:"neohaskell",label:"NeoHaskell",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"catAge = Age 2\n"))),(0,o.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const catAge = Age(2);\n")))),(0,o.kt)("p",null,"Note how now, you cannot use it as another ",(0,o.kt)("inlineCode",{parentName:"p"},"Int"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> catAge + 4\n\n-- TYPE MISMATCH ----------------------------\nAttempting to add two values, but the first value doesn't match the type of the second value:\n\n    catAge + 4\n    ^^^^^^\n\n`catAge` is of type:\n\n    Age\n\nBut `(+)` needs the 1st argument to be:\n\n    Int\n\nHint: Maybe try using `cast`?\n")),(0,o.kt)("p",null,"The error message suggests the use of ",(0,o.kt)("inlineCode",{parentName:"p"},"cast")," ",(0,o.kt)(i.Z,{issue:"80",mdxType:"Badge"}),", which is a function that allows you to\ncast a wrapper type to the type that it wraps, with no performance penalty. We can use\nit like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> cast catAge + 4\n6\n")),(0,o.kt)("p",null,"In this case, the compiler knows that ",(0,o.kt)("inlineCode",{parentName:"p"},"catAge")," is of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Age"),", and that ",(0,o.kt)("inlineCode",{parentName:"p"},"4")," is of type ",(0,o.kt)("inlineCode",{parentName:"p"},"Int"),",\nso it casts ",(0,o.kt)("inlineCode",{parentName:"p"},"catAge")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," and then adds it to ",(0,o.kt)("inlineCode",{parentName:"p"},"4"),"."),(0,o.kt)("h3",{id:"why-do-i-have-to-cast-it"},"Why do I have to cast it?"),(0,o.kt)("p",null,"The reason for wrapper types is that they not only give names to other types, but also that they\ngive you a way to differentiate them from the other types. This is useful for when you want to\ncreate functions that only accept a certain subset of types."),(0,o.kt)("p",null,"It is common that we create a function that accepts many ",(0,o.kt)("inlineCode",{parentName:"p"},"Int"),"s as its arguments, but we\nwant to differentiate them from each other. For example, we could have a function that\naccepts a ",(0,o.kt)("inlineCode",{parentName:"p"},"weight")," and a ",(0,o.kt)("inlineCode",{parentName:"p"},"distance")," as arguments, and we want to differentiate them from each\nother."),(0,o.kt)("p",null,"Without wrapper types, we could easily mix them up, making the function call to be\nincorrect:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> :{\n  calculateEnergy weight distance = ...\n  :}\n\nneo> myWeight = 42\nneo> myDistance = 31415\nneo> calculateEnergy myDistance myWeight  -- Oops, we mixed them up!\n")),(0,o.kt)("p",null,"To solve this, we could make use of wrapper types, but we also need to know how to specify the types of\nthe arguments of a function. Let's check that out."),(0,o.kt)("h2",{id:"annotating-functions"},"Annotating Functions"),(0,o.kt)("p",null,"Although the compiler doesn't enforce it, you ",(0,o.kt)("strong",{parentName:"p"},"should")," annotate the types of the arguments. Even more,\nthe NeoHaskell good practices recommends that you write the type of the function ",(0,o.kt)("strong",{parentName:"p"},"before")," beggining to\nwrite the function's implementation."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The NeoHaskell good practices recommends that you write the type of the function ",(0,o.kt)("strong",{parentName:"p"},"before")," beggining to\nwrite the function's implementation.")),(0,o.kt)("p",null,"This is because, as we mentioned earlier, types are a powerful tool for designing our programs, and\nthey are a great way to communicate the intent of our functions. But this is only true if we ensure that\nwe have good design pieces to work with, like the wrapper types we just saw."),(0,o.kt)("p",null,"To annotate the arguments and result types of a function, we write the types of the arguments separated by\narrows like ",(0,o.kt)("inlineCode",{parentName:"p"},"->"),", being the last one the result type. For example, if we wanted to annotate the\n",(0,o.kt)("inlineCode",{parentName:"p"},"calculateEnergy")," function, we could do it like so:"),(0,o.kt)(r.Z,{mdxType:"Tabs"},(0,o.kt)(l.Z,{value:"neohaskell",label:"NeoHaskell",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"calculateEnergy :: Int -> Int -> Int\ncalculateEnergy weight distance = ...\n"))),(0,o.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const calculateEnergy = (weight: number, distance: number): number => ...\n")))),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"It is common that newcomers find it weird that there's no separation between the arguments and the result type,\nlike with a parenthesis or something. This is because it is very useful for a thing called ",(0,o.kt)("em",{parentName:"p"},"partial application"),",\nwhich we will see in future sections.")),(0,o.kt)("p",null,"Note how the ",(0,o.kt)("inlineCode",{parentName:"p"},"calculateEnergy")," function accepts two ",(0,o.kt)("inlineCode",{parentName:"p"},"Int"),"s as arguments, and returns an ",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," as a result. But we\nstill have the problem of mixing up the arguments, so let's fix that."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"types are a lie meme",src:n(4258).Z,width:"882",height:"1200"})),(0,o.kt)("p",null,"A good way of measuring whether a type annotation is good or not, is to check if it is possible to figure out the\nimplementation of the function just by looking at the type annotation. In this case, we can't, because we don't\nknow which argument is which, neither if we need to pass ",(0,o.kt)("inlineCode",{parentName:"p"},"weight"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"distance")," or even maybe some other ",(0,o.kt)("inlineCode",{parentName:"p"},"Int")," that\nwe don't know about."),(0,o.kt)("p",null,"Given that weight and distance are two units that probably make sense in our domain, we can create wrapper types\nfor them:"),(0,o.kt)(r.Z,{mdxType:"Tabs"},(0,o.kt)(l.Z,{value:"neohaskell",label:"NeoHaskell",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"newtype Weight = Weight Int\nnewtype Distance = Distance Int\n"))),(0,o.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'type Weight = number & { __tag: "Weight" };\nconst Weight = (weight: number): Weight => weight as Weight;\n\ntype Distance = number & { __tag: "Distance" };\nconst Distance = (distance: number): Distance => distance as Distance;\n')))),(0,o.kt)("p",null,"Now, we can use these wrapper types to annotate the arguments of the ",(0,o.kt)("inlineCode",{parentName:"p"},"calculateEnergy")," function:"),(0,o.kt)(r.Z,{mdxType:"Tabs"},(0,o.kt)(l.Z,{value:"neohaskell",label:"NeoHaskell",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"calculateEnergy :: Weight -> Distance -> Int\ncalculateEnergy weight distance = ...\n"))),(0,o.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const calculateEnergy = (weight: Weight, distance: Distance): number => ...\n")))),(0,o.kt)("p",null,"Now it is much better, but we can improve it even more. Is the weight in kilograms? In pounds? In grams? Is the\ndistance in meters? In kilometers? In miles? In light years? We don't know, and we can't know just by looking at\nthe type annotation. Also, we have no clue about the result type, is it in joules? In calories? In kilocalories?"),(0,o.kt)("p",null,"Let's fix that by creating more wrapper types, and changing the type annotation of the function:"),(0,o.kt)(r.Z,{mdxType:"Tabs"},(0,o.kt)(l.Z,{value:"neohaskell",label:"NeoHaskell",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"newtype Kilograms = Kilograms Int\nnewtype Meters = Meters Int\nnewtype Joules = Joules Int\n\ncalculateEnergy :: Kilograms -> Meters -> Joules\ncalculateEnergy weight distance = ...\n"))),(0,o.kt)(l.Z,{value:"ts",label:"TypeScript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'type Kilograms = number & { __tag: "Kilograms" };\nconst Kilograms = (weight: number): Kilograms => weight as Kilograms;\n\ntype Meters = number & { __tag: "Meters" };\nconst Meters = (distance: number): Meters => distance as Meters;\n\ntype Joules = number & { __tag: "Joules" };\nconst Joules = (energy: number): Joules => energy as Joules;\n\nconst calculateEnergy = (weight: Kilograms, distance: Meters): Joules => ...\n')))),(0,o.kt)("p",null,"This is much better, if we take a quick glance at the type annotation, it is very clear what the function does,\nand what it expects as arguments and what it returns as a result."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"calculateEnergy :: Kilograms -> Meters -> Joules\n")),(0,o.kt)("p",null,"We haven't looked at the implementation, and it really doesn't matter, because there's a ",(0,o.kt)("strong",{parentName:"p"},"contract")," that has been\nspecified for this function. It is a contract that we can trust, because it is enforced by the compiler."),(0,o.kt)("p",null,"And remember! Functions in NeoHaskell cannot fail, so if you see a function that returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"Joules"),", you can be\nsure that it will return a ",(0,o.kt)("inlineCode",{parentName:"p"},"Joules")," value ",(0,o.kt)("strong",{parentName:"p"},"always"),", and it will never crash."),(0,o.kt)("p",null,"This is the true power of types, they are a powerful tool for designing our programs, and they are a great way to\nremove the need of having to read the implementation of a function to understand what it does."),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"In this section, we've seen how to annotate the types of constants and functions, and how to create wrapper types\nto avoid primitive obsession."),(0,o.kt)("p",null,"We have dipped our toes into what they call ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Domain-driven_design"},"Domain Driven Design"),"\nor DDD, which is the way of designing software that NeoHaskell inspires from."),(0,o.kt)("p",null,"NeoHaskell's way of approaching software development is very different to other programming languages, because it makes\nyou think about the design of your program before you even start writing it. At first, it might seem like a lot of work,\nbut in exchange, you get tools that make your life easier, and your head free of worries."))}g.isMDXComponent=!0},4258:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/types_lie-18c07e96b5c53a03db37a1840ce8ea33.jpeg"}}]);