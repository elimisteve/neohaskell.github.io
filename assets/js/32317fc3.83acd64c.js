"use strict";(self.webpackChunkneohaskell_github_io=self.webpackChunkneohaskell_github_io||[]).push([[938],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=p(n),m=r,h=c["".concat(s,".").concat(m)]||c[m]||u[m]||o;return n?a.createElement(h,l(l({ref:t},d),{},{components:n})):a.createElement(h,l({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[c]="string"==typeof e?e:r,l[1]=i;for(var p=2;p<o;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},165:(e,t,n)=>{n.d(t,{Z:()=>r});var a=n(7294);const r=e=>{let{issue:t,absolute:n}=e;const[r,o]=a.useState("loading"),[l,i]=a.useState();(0,a.useEffect)((()=>{try{fetch(`https://api.github.com/repos/neohaskell/neohaskell/issues/${t}`).then((e=>e.json())).then((e=>{e&&(o(e.state),i(e.title))}))}catch(e){console.error(e)}}),[]);const s=r?`NOT IMPLEMENTED YET: #${t} - ${l}`:"LOADING",p=`tooltip ${n?"absolute z-10 p-4":""}`;return a.createElement("a",{className:p,"data-tip":s,target:"_blank",href:`https://github.com/neohaskell/neohaskell/issues/${t}`},a.createElement("div",{className:`badge border-black ${{open:"badge-warning",closed:"hidden",loading:"badge-primary"}[r]} badge-lg`}))}},660:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>s,toc:()=>d});var a=n(7462),r=(n(7294),n(3905)),o=n(165);const l={sidebar_position:0},i="Doing Math",s={unversionedId:"essentials/math",id:"essentials/math",title:"Doing Math",description:"The documentation that you're reading is a design document where most of",source:"@site/docs/essentials/math.mdx",sourceDirName:"essentials",slug:"/essentials/math",permalink:"/docs/essentials/math",draft:!1,editUrl:"https://github.com/neohaskell/neohaskell.github.io/tree/main/docs/essentials/math.mdx",tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0},sidebar:"tutorialSidebar",previous:{title:"Playing with the REPL",permalink:"/docs/getting-started/interactive-console"},next:{title:"Extra Topics",permalink:"/docs/category/extra-topics"}},p={},d=[{value:'Basic Math <Badge issue="22"/>',id:"basic-math-",level:2},{value:"Trying it in the REPL",id:"trying-it-in-the-repl",level:2},{value:"Spacing doesn&#39;t matter",id:"spacing-doesnt-matter",level:3},{value:"More Advanced Math",id:"more-advanced-math",level:2}],c={toc:d},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"doing-math"},"Doing Math"),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"The documentation that you're reading is a design document where most of\nthe features you're reading are yet to be implemented. Check the ",(0,r.kt)("a",{parentName:"p",href:"/docs/docs-intro"},"Note on the Docs"))),(0,r.kt)("p",null,"As the Professor Walter White said once, \"Jesse, let's cook some math\", or something like that, I don't know."),(0,r.kt)("p",null,"Anyways, let's get to the point."),(0,r.kt)("h2",{id:"basic-math-"},"Basic Math ",(0,r.kt)(o.Z,{issue:"22",mdxType:"Badge"})),(0,r.kt)("p",null,"Here's a table of the typical math operators in NeoHaskell and what they do:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Operator"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"+")),(0,r.kt)("td",{parentName:"tr",align:null},"Adds two numbers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"-")),(0,r.kt)("td",{parentName:"tr",align:null},"Subtracts two numbers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"*")),(0,r.kt)("td",{parentName:"tr",align:null},"Multiplies two numbers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"/")),(0,r.kt)("td",{parentName:"tr",align:null},"Divides two numbers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"^")),(0,r.kt)("td",{parentName:"tr",align:null},"Raises a number to a power")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"%")),(0,r.kt)("td",{parentName:"tr",align:null},"Gets the remainder of a division")))),(0,r.kt)("h2",{id:"trying-it-in-the-repl"},"Trying it in the REPL"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Addition Example:")," Lets say that I want to add 56 and 72 and find its result, I can do it as shown:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> 56+72\n128\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Subtraction Example:")," In this example I am subtracting 64 from 112"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> 112-64\n48\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Division Example:")," Lets say I want to divide 117 by 12 and find the quotient, I can do it in NeoHaskell like this"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> 117/12\n9\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Power Example:")," Lets say I want to find what we will get by cubing five (five raised to the power of three), I can do it in NeoHaskell as shown"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> 5^3\n125\n")),(0,r.kt)("p",null,"Modulus or Remainder Example: I want to know what we will get as remainder when we divide 21 by 4, I can do it as shown"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> 21%4\n1\n")),(0,r.kt)("h3",{id:"spacing-doesnt-matter"},"Spacing doesn't matter"),(0,r.kt)("p",null,"NeoHaskell doesn't care about spacing, you can write the above examples as shown below and it will still work"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> 56 + 72\n128\n\nneo> 112         - 64\n48\n\nneo> 117 /              12\n9\n\nneo> 5 ^3\n125\n")),(0,r.kt)("h2",{id:"more-advanced-math"},"More Advanced Math"),(0,r.kt)("p",null,"More advanced math functions are available in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Math")," module. It is\navailable by default, so you don't need to import it."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Modules? Import? What??")),(0,r.kt)("p",null,"Don't worry, we'll get to that later. For now, just know that you can use\ndo some math operations like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> Math.sin 90\n0.8939966636005579\n\nneo> Math.sqrt 64\n8\n\nneo> Math.log 10\n2.302585092994046\n")),(0,r.kt)("p",null,"You can experiment and explore the advanced math functions available by\ntyping ",(0,r.kt)("inlineCode",{parentName:"p"},"Math.")," and then pressing ",(0,r.kt)("inlineCode",{parentName:"p"},"TAB")," to see the list of functions."))}m.isMDXComponent=!0}}]);