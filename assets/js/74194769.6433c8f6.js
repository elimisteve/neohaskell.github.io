"use strict";(self.webpackChunkneohaskell_github_io=self.webpackChunkneohaskell_github_io||[]).push([[451],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var r=a.createContext({}),c=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(r.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,r=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=o,d=p["".concat(r,".").concat(m)]||p[m]||h[m]||i;return n?a.createElement(d,l(l({ref:t},u),{},{components:n})):a.createElement(d,l({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,l=new Array(i);l[0]=m;var s={};for(var r in t)hasOwnProperty.call(t,r)&&(s[r]=t[r]);s.originalType=e,s[p]="string"==typeof e?e:o,l[1]=s;for(var c=2;c<i;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},165:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(7294);const o=e=>{let{issue:t,absolute:n}=e;const[o,i]=a.useState("loading"),[l,s]=a.useState();(0,a.useEffect)((()=>{try{fetch(`https://api.github.com/repos/neohaskell/neohaskell/issues/${t}`).then((e=>e.json())).then((e=>{e&&(i(e.state),s(e.title))}))}catch(e){console.error(e)}}),[]);const r=o?`NOT IMPLEMENTED YET: #${t} - ${l}`:"LOADING",c=`tooltip ${n?"absolute z-10 p-4":""}`;return a.createElement("a",{className:c,"data-tip":r,target:"_blank",href:`https://github.com/neohaskell/neohaskell/issues/${t}`},a.createElement("div",{className:`badge border-black ${{open:"badge-warning",closed:"hidden",loading:"badge-primary"}[o]} badge-lg`}))}},1645:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(7294);function o(e){let{src:t,sourceLink:n,alt:o}=e;return a.createElement("figure",{className:"!flex !flex-col !place-items-center"},a.createElement("img",{src:t,alt:o}),a.createElement("figcaption",{className:"!text-xs"},`Source: ${n}`))}},4768:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(7462),o=(n(7294),n(3905));n(165),n(1645);const i={sidebar_position:2},l="Laziness",s={unversionedId:"essentials/laziness",id:"essentials/laziness",title:"Laziness",description:"The documentation that you're reading is a design document where most of",source:"@site/docs/essentials/laziness.mdx",sourceDirName:"essentials",slug:"/essentials/laziness",permalink:"/docs/essentials/laziness",draft:!1,editUrl:"https://github.com/neohaskell/neohaskell.github.io/tree/main/docs/essentials/laziness.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Constants",permalink:"/docs/essentials/constants"},next:{title:"Extra Topics",permalink:"/docs/category/extra-topics"}},r={},c=[{value:"What is lazy evaluation?",id:"what-is-lazy-evaluation",level:2},{value:"Laziness in NeoHaskell",id:"laziness-in-neohaskell",level:2},{value:"Fixing the Freeze from the Constants Page",id:"fixing-the-freeze-from-the-constants-page",level:2}],u={toc:c},p="wrapper";function h(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"laziness"},"Laziness"),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"The documentation that you're reading is a design document where most of\nthe features you're reading are yet to be implemented. Check the ",(0,o.kt)("a",{parentName:"p",href:"/docs/docs-intro"},"Note on the Docs"))),(0,o.kt)("p",null,"NeoHaskell is a lazy language. Not only because it gives you a lot of tools so you can focus on what matters in your app,\nbut also because it is ",(0,o.kt)("strong",{parentName:"p"},"lazily evaluated"),"."),(0,o.kt)("p",null,"Lazy evaluation is especially beneficial because it can improve application load time, and it can also improve performance\nin some cases."),(0,o.kt)("h2",{id:"what-is-lazy-evaluation"},"What is lazy evaluation?"),(0,o.kt)("p",null,"Normally, in programming languages like JavaScript, when we create a variable and assign it a value, the value is calculated\nimmediately. We say that this value has been evaluated ",(0,o.kt)("strong",{parentName:"p"},"eagerly"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const myConstant = 1 + 1;\n\nconsole.log(myConstant); // 2\n")),(0,o.kt)("p",null,"When we load that JavaScript code, the first that would happen is that the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant")," would be calculated and stored\nin memory."),(0,o.kt)("p",null,"Then, whenever we wanted to use the value (like in the ",(0,o.kt)("inlineCode",{parentName:"p"},"console.log"),"), we would just retrieve the value from memory."),(0,o.kt)("p",null,"Imagine that instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"1 + 1"),", we had a very complex expression that took a long time to calculate. If we were to load that\nJavaScript code, we would have to wait for the expression to be calculated before we could use the value."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const myConstant = get500thDigitOfPi();\n\nconsole.log(myConstant);\n")),(0,o.kt)("p",null,"This JavaScript code would take a lot of time to load, because it would have to wait for ",(0,o.kt)("inlineCode",{parentName:"p"},"get500thDigitOfPi")," to finish."),(0,o.kt)("p",null,"A technique that is usually used in these cases is to wrap the calculation in a function, so that the calculation is only\nperformed when the function is called:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const myConstant = () => get500thDigitOfPi();\n\nconsole.log(myConstant); // [Function]\n")),(0,o.kt)("p",null,"Now we have a problem: we can't use the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant")," directly, because it is a function. We have to call the function\nfirst:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const myConstant = () => get500thDigitOfPi();\n\nconsole.log(myConstant()); // 2\n\n// Let's call that again\nconsole.log(myConstant()); // 2\n")),(0,o.kt)("p",null,"Now we have another problem, which is that each time that we call ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant"),", the function ",(0,o.kt)("inlineCode",{parentName:"p"},"get500thDigitOfPi")," is called again,\ntaking a long time to calculate the value, which doesn't change. So in languages like JavaScript, we would need to implement some\nkind of method to store the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant")," after it has been calculated, so that we don't have to calculate it again."),(0,o.kt)("h2",{id:"laziness-in-neohaskell"},"Laziness in NeoHaskell"),(0,o.kt)("p",null,"In NeoHaskell, by default all values are lazy. As we saw in the previous section, this means that the value of a variable is not\ncalculated until it is needed."),(0,o.kt)("p",null,"The cool part of having this as a first-class feature of the language is that we don't have to be thinking about wrapping the\nvalue in a function, calling the function, or storing the value after it has been calculated. The compiler will do that for us automatically."),(0,o.kt)("p",null,"When you define a constant in NeoHaskell, it is lazy by default:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> myConstant = 1 + 1\n")),(0,o.kt)("p",null,"It doesn't matter if the calculation is ",(0,o.kt)("inlineCode",{parentName:"p"},"1 + 1")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"get500thDigitOfPi"),", the creation of the constant is instant, because it is\nnot calculated."),(0,o.kt)("h2",{id:"fixing-the-freeze-from-the-constants-page"},"Fixing the Freeze from the Constants Page"),(0,o.kt)("p",null,"In the previous page, we tried to increment a constant by one, but it froze."),(0,o.kt)("p",null,"The reason for this, is that due to lazy evaluation, the compiler allows us to define a constant in terms of itself, but\nwhen it tries to calculate it freezes."),(0,o.kt)("p",null,"The compiler tries to calculate the value like this (imagine that the comments are being said by the compiler):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> myConstant = myConstant + 1\n-- I received `myConstant = myConstant + 1`!\n-- I'm storing the expression `myConstant + 1` as the value of `myConstant`!\n\nneo> myConstant\n-- Oh, I need to calculate the value of `myConstant`, in order to print it!\n\n-- Let me check the value of `myConstant`...\n-- Ok, it is the expression `myConstant + 1`! Let me calculate that...\n-- First, I need to get the value of `myConstant`...\n\n-- Let me check the value of `myConstant`...\n-- Ok, it is the expression `myConstant + 1`! Let me calculate that...\n-- First, I need to get the value of `myConstant`...\n\n-- Let me check the value of `myConstant`...\n-- Ok, it is the expression `myConstant + 1`! Let me calculate that...\n-- First, I need to get the value of `myConstant`...\n\n-- Let me check the value of `myConstant`...\n-- Ok, it is the expression `myConstant + 1`! Let me calculate that...\n-- First, I need to get the value of `myConstant`...\n")),(0,o.kt)("p",null,"And so on. The compiler will keep trying to calculate the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant")," forever, because it is defined as ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant = myConstant + 1"),", and it will never be able to calculate the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant"),"."),(0,o.kt)("p",null,"This is a suprirising behavior for newcomers, but it is actually a very useful feature that allows the compiler to perform many\noptimizations to make your code more performant."),(0,o.kt)("p",null,"A cool, but not very useful, example of this is that you can create infinite things, like infinite lists. Try running this in\nthe NeoHaskell REPL (remember to press ",(0,o.kt)("inlineCode",{parentName:"p"},"Ctrl + C")," to stop it):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> unlimitedPower = unlimitedPower |> List.prepend 1\nneo> unlimitedPower\n")),(0,o.kt)("p",null,"You might be already asking yourself, what does (",(0,o.kt)("inlineCode",{parentName:"p"},"|>"),") mean? What is ",(0,o.kt)("inlineCode",{parentName:"p"},"List.prepend"),"? Don't worry, we'll get to that in the next\nsections."))}h.isMDXComponent=!0}}]);