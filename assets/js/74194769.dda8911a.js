"use strict";(self.webpackChunkneohaskell_github_io=self.webpackChunkneohaskell_github_io||[]).push([[6451],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var i=n.createContext({}),u=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=u(e.components);return n.createElement(i.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,l=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(a),d=o,h=p["".concat(i,".").concat(d)]||p[d]||m[d]||l;return a?n.createElement(h,r(r({ref:t},c),{},{components:a})):n.createElement(h,r({ref:t},c))}));function h(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var l=a.length,r=new Array(l);r[0]=d;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[p]="string"==typeof e?e:o,r[1]=s;for(var u=2;u<l;u++)r[u]=a[u];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},5162:(e,t,a)=>{a.d(t,{Z:()=>r});var n=a(7294),o=a(6010);const l={tabItem:"tabItem_Ymn6"};function r(e){let{children:t,hidden:a,className:r}=e;return n.createElement("div",{role:"tabpanel",className:(0,o.Z)(l.tabItem,r),hidden:a},t)}},4866:(e,t,a)=>{a.d(t,{Z:()=>w});var n=a(7462),o=a(7294),l=a(6010),r=a(2466),s=a(6550),i=a(1980),u=a(7392),c=a(12);function p(e){return function(e){return o.Children.map(e,(e=>{if(!e||(0,o.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:o}}=e;return{value:t,label:a,attributes:n,default:o}}))}function m(e){const{values:t,children:a}=e;return(0,o.useMemo)((()=>{const e=t??p(a);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function d(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:a}=e;const n=(0,s.k6)(),l=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,i._X)(l),(0,o.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(n.location.search);t.set(l,e),n.replace({...n.location,search:t.toString()})}),[l,n])]}function f(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,l=m(e),[r,s]=(0,o.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!d({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:l}))),[i,u]=h({queryString:a,groupId:n}),[p,f]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,l]=(0,c.Nk)(a);return[n,(0,o.useCallback)((e=>{a&&l.set(e)}),[a,l])]}({groupId:n}),g=(()=>{const e=i??p;return d({value:e,tabValues:l})?e:null})();(0,o.useLayoutEffect)((()=>{g&&s(g)}),[g]);return{selectedValue:r,selectValue:(0,o.useCallback)((e=>{if(!d({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);s(e),u(e),f(e)}),[u,f,l]),tabValues:l}}var g=a(2389);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){let{className:t,block:a,selectedValue:s,selectValue:i,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:p}=(0,r.o5)(),m=e=>{const t=e.currentTarget,a=c.indexOf(t),n=u[a].value;n!==s&&(p(t),i(n))},d=e=>{let t=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const a=c.indexOf(e.currentTarget)+1;t=c[a]??c[0];break}case"ArrowLeft":{const a=c.indexOf(e.currentTarget)-1;t=c[a]??c[c.length-1];break}}t?.focus()};return o.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":a},t)},u.map((e=>{let{value:t,label:a,attributes:r}=e;return o.createElement("li",(0,n.Z)({role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,key:t,ref:e=>c.push(e),onKeyDown:d,onClick:m},r,{className:(0,l.Z)("tabs__item",y.tabItem,r?.className,{"tabs__item--active":s===t})}),a??t)})))}function v(e){let{lazy:t,children:a,selectedValue:n}=e;const l=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=l.find((e=>e.props.value===n));return e?(0,o.cloneElement)(e,{className:"margin-top--md"}):null}return o.createElement("div",{className:"margin-top--md"},l.map(((e,t)=>(0,o.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function k(e){const t=f(e);return o.createElement("div",{className:(0,l.Z)("tabs-container",y.tabList)},o.createElement(b,(0,n.Z)({},e,t)),o.createElement(v,(0,n.Z)({},e,t)))}function w(e){const t=(0,g.Z)();return o.createElement(k,(0,n.Z)({key:String(t)},e))}},165:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(7294);const o=e=>{let{issue:t,absolute:a}=e;const[o,l]=n.useState("loading"),[r,s]=n.useState();(0,n.useEffect)((()=>{try{fetch(`https://api.github.com/repos/neohaskell/neohaskell/issues/${t}`).then((e=>e.json())).then((e=>{e&&(l(e.state),s(e.title))}))}catch(e){console.error(e)}}),[]);const i=o?`NOT IMPLEMENTED YET: #${t} - ${r}`:"LOADING",u=`tooltip ${a?"absolute z-10 p-4":""}`;return n.createElement("a",{className:u,"data-tip":i,target:"_blank",href:`https://github.com/neohaskell/neohaskell/issues/${t}`},n.createElement("div",{className:`badge border-black ${{open:"badge-warning",closed:"hidden",loading:"badge-primary"}[o]} badge-lg`}))}},1645:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(7294);function o(e){let{src:t,sourceLink:a,alt:o}=e;return n.createElement("figure",{className:"!flex !flex-col !place-items-center"},n.createElement("img",{src:t,alt:o}),n.createElement("figcaption",{className:"!text-xs"},`Source: ${a}`))}},4768:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>u,toc:()=>p});var n=a(7462),o=(a(7294),a(3905)),l=a(4866),r=a(5162);a(165),a(1645);const s={sidebar_position:2},i="Laziness",u={unversionedId:"essentials/laziness",id:"essentials/laziness",title:"Laziness",description:"The documentation that you're reading is a design document where most of",source:"@site/docs/essentials/laziness.mdx",sourceDirName:"essentials",slug:"/essentials/laziness",permalink:"/docs/essentials/laziness",draft:!1,editUrl:"https://github.com/neohaskell/neohaskell.github.io/tree/main/docs/essentials/laziness.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Constants",permalink:"/docs/essentials/constants"},next:{title:"Functions",permalink:"/docs/essentials/functions"}},c={},p=[{value:"What is lazy evaluation?",id:"what-is-lazy-evaluation",level:2},{value:"Laziness in NeoHaskell",id:"laziness-in-neohaskell",level:2},{value:"Understanding the Freeze from the Constants Page",id:"understanding-the-freeze-from-the-constants-page",level:2}],m={toc:p},d="wrapper";function h(e){let{components:t,...a}=e;return(0,o.kt)(d,(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"laziness"},"Laziness"),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"The documentation that you're reading is a design document where most of\nthe features you're reading are yet to be implemented. Check the ",(0,o.kt)("a",{parentName:"p",href:"/docs/docs-intro"},"Note on the Docs"))),(0,o.kt)("p",null,"NeoHaskell is a lazy language. Not only because it gives you a lot of tools so you can focus on what matters in your app,\nbut also because it is ",(0,o.kt)("strong",{parentName:"p"},"lazily evaluated"),"."),(0,o.kt)("p",null,"Lazy evaluation is especially beneficial because it can improve application load time, and it can also improve performance\nin some cases."),(0,o.kt)("h2",{id:"what-is-lazy-evaluation"},"What is lazy evaluation?"),(0,o.kt)("p",null,"Normally, in programming languages like JavaScript, when we create a variable and assign it a value, the value is calculated\nimmediately. We say that this value has been evaluated ",(0,o.kt)("strong",{parentName:"p"},"eagerly"),":"),(0,o.kt)(l.Z,{mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const myConstant = 1 + 1;\n\nconsole.log(myConstant); // 2\n")))),(0,o.kt)("p",null,"When we load that JavaScript code, the first that would happen is that the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant")," would be calculated and stored\nin memory."),(0,o.kt)("p",null,"Then, whenever we wanted to use the value (like in the ",(0,o.kt)("inlineCode",{parentName:"p"},"console.log"),"), we would just retrieve the value from memory."),(0,o.kt)("p",null,"Imagine that instead of ",(0,o.kt)("inlineCode",{parentName:"p"},"1 + 1"),", we had a very complex expression that took a long time to calculate. If we were to load that\nJavaScript code, we would have to wait for the expression to be calculated before we could use the value."),(0,o.kt)(l.Z,{mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const myConstant = get500thDigitOfPi();\n\nconsole.log(myConstant);\n")))),(0,o.kt)("p",null,"This JavaScript code would take a lot of time to load, because it would have to wait for ",(0,o.kt)("inlineCode",{parentName:"p"},"get500thDigitOfPi")," to finish."),(0,o.kt)("p",null,"A technique that is usually used in these cases is to wrap the calculation in a function, so that the calculation is only\nperformed when the function is called:"),(0,o.kt)(l.Z,{mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const myConstant = () => get500thDigitOfPi();\n\nconsole.log(myConstant); // [Function]\n")))),(0,o.kt)("p",null,"Now we have a problem: we can't use the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant")," directly, because it is a function. We have to call the function\nfirst:"),(0,o.kt)(l.Z,{mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const myConstant = () => get500thDigitOfPi();\n\nconsole.log(myConstant()); // 2  (after a long time)\n\n// If we call this again, the calculation gets performed twice.\nconsole.log(myConstant()); // 2  (after a long time, again)\n")))),(0,o.kt)("p",null,"Now we have another problem, which is that each time that we call ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant"),", the function ",(0,o.kt)("inlineCode",{parentName:"p"},"get500thDigitOfPi")," is called again,\ntaking a long time to calculate the value, which doesn't change. So in languages like JavaScript, we would need to implement some\nkind of method to store the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant")," after it has been calculated, so that we don't have to calculate it again."),(0,o.kt)("h2",{id:"laziness-in-neohaskell"},"Laziness in NeoHaskell"),(0,o.kt)("p",null,"In NeoHaskell, by default all values are lazy. As we saw in the previous section, this means that the value of a variable is not\ncalculated until it is needed."),(0,o.kt)("p",null,"The cool part of having this as a first-class feature of the language is that we don't have to be thinking about wrapping the\nvalue in a function, calling the function, or storing the value after it has been calculated. The compiler will do that for us automatically."),(0,o.kt)("p",null,"When you define a constant in NeoHaskell, it is lazy by default:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> myConstant = 1 + 1\n")),(0,o.kt)("p",null,"It doesn't matter if the calculation is ",(0,o.kt)("inlineCode",{parentName:"p"},"1 + 1")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"get500thDigitOfPi"),", the creation of the constant is instant, because it is\nnot calculated."),(0,o.kt)("h2",{id:"understanding-the-freeze-from-the-constants-page"},"Understanding the Freeze from the Constants Page"),(0,o.kt)("p",null,"In the previous page, we tried to increment a constant by one, but it froze."),(0,o.kt)("p",null,"The reason for this, is that due to lazy evaluation, the compiler allows us to define a constant in terms of itself, but\nwhen it tries to calculate it freezes."),(0,o.kt)("p",null,"The compiler tries to calculate the value like this (imagine that the comments are being said by the compiler):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-haskell"},"neo> myConstant = myConstant + 1\n-- I received `myConstant = myConstant + 1`!\n-- I'm storing the expression `myConstant + 1` as the value of `myConstant`!\n\nneo> myConstant\n-- Oh, I need to calculate the value of `myConstant`, in order to print it!\n\n-- Let me check the value of `myConstant`...\n-- Ok, it is the expression `myConstant + 1`! Let me calculate that...\n-- First, I need to get the value of `myConstant`...\n\n-- Let me check the value of `myConstant`...\n-- Ok, it is the expression `myConstant + 1`! Let me calculate that...\n-- First, I need to get the value of `myConstant`...\n\n-- Let me check the value of `myConstant`...\n-- Ok, it is the expression `myConstant + 1`! Let me calculate that...\n-- First, I need to get the value of `myConstant`...\n\n-- Let me check the value of `myConstant`...\n-- Ok, it is the expression `myConstant + 1`! Let me calculate that...\n-- First, I need to get the value of `myConstant`...\n")),(0,o.kt)("p",null,"And so on. The compiler will keep trying to calculate the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant")," forever, because it is defined as ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant = myConstant + 1"),", and it will never be able to calculate the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"myConstant"),"."),(0,o.kt)("p",null,"This is a suprirising behavior for newcomers, but it is actually a very useful feature that allows the compiler to perform many\noptimizations to make your code more performant."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"For example"),", imagine that you have a single-page application that defines two completely different pages for registering a\nuser: In one, the registered user is a person, in another the registered user is a company."),(0,o.kt)("p",null,"A naive implementation in JavaScript would be to have a single ",(0,o.kt)("inlineCode",{parentName:"p"},"registerUser")," function that receives a ",(0,o.kt)("inlineCode",{parentName:"p"},"userType")," parameter,\nand depending on the value of that parameter, it would perform a different action:"),(0,o.kt)(l.Z,{mdxType:"Tabs"},(0,o.kt)(r.Z,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'const registerPersonPage = // ...\nconst registerCompanyPage = // ...\n\nif (userType === "person") {\n  return registerPersonPage;\n} else {\n  return registerCompanyPage;\n}\n')))),(0,o.kt)("p",null,"You see the issue here, both pages are being loaded when the code is loaded, even though only one of them will be used."),(0,o.kt)("p",null,"In contrast, in NeoHaskell, the pages wouldn't be loaded until they are needed, because their values would be lazily evaluated."))}h.isMDXComponent=!0}}]);